\documentclass[a4paper, 11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[swedish, english]{babel} % last language the main one
\usepackage[T1]{fontenc}
%--------------
\usepackage{amsmath}
\usepackage[per=slash]{siunitx}
\usepackage{graphicx}
\usepackage{hyperref}  % maybe useful
\usepackage{placeins} % to get \FloatBarrier
\usepackage{fixltx2e} % to get  \textsubscript{}
\setlength\parindent{0pt}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage[usenames,dvipsnames]{xcolor}  % to get colour
\usepackage[margin=1.2in]{geometry} %sets margin size (defaulft for 11pt is 1.75in)
\usepackage{caption}
\usepackage{subcaption}
\usepackage{afterpage}
\usepackage{tikz} 
\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{arrow} = [thick, ->, >=stealth]
%------------------
\setcounter{secnumdepth}{1}  %  depth to which section numbering occurs
%--------------------- To make a header (use \thispagestyle{empty} to remove headers etc)
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{SF3565, Project 1, September 2016}
\rhead{HÃ¤ggmark, Karlsson}
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0.4pt} % write 0pt to remove header line
%\renewcommand{\footrulewidth}{0.4pt}

\usepackage{amssymb} %might cause problem with the SI units package.

\begin{document}

\section*{2 Adaptive Simpson Integration (ASI)}


The source code for task 2 contains two main functions, ASI and recursiveASI. The latter is more intuitive but left here only as a comparison.\\

The ASI funtion takes four parameters. A function pointer, that points to the function giving the integrand, Two doubles, lower and upper integration limit, and finally a double that sets the error tolerance. The Adaptive Simpson Integration is implemented using a while loop that runs as long as the approximate error is bigger than the given tolerance. Inside the while is a for loop that calculates the integral of an integrand $f$, from $a$ to $b$ by splitting the integration interval into $n$ subintervals, calculating the subintervals with the integral approximation, i.e.

$$ I(a,b) = \frac{b-a}{6} \left (f(a)+4f\left(\frac{a+b}{2}\right) +f(b) \right )$$

and then summing them up. After this the approximate error is calculated and an if-statement is checked to see if the error is small enough and the loop can be broken. If the error is too big the number of intervals, $n$ is doubled and the loop starts anew.\\

The subintervals are calculated by another for loop and stored in a vector: 

$$ \textrm{intervals} = [ a, a+h, a+2h,a+3h,..., b ], \qquad   h = \frac{b-a}{\textrm{n}}$$

where $a$ is the lower limit of the integral, $b$ is the upper limit, $n$ is the number of subintervals and $h$ is the subinterval length.\\

The result of the two ASI implementation is shown in the table below.

 \begin{figure}[htbp]
 \begin{center}
   \begin{tabular}{ l || l  l |  l  l }
     %\hline
     tol & ASI (recursive) & error  & ASI (while-loop) & error \\ \hline
     0.01     & 2.505996 & 0.005187   & 2.4995921 & 0.001217\\ %\hline
     0.001   & 2.499856 & 0.000952   & 2.5007683 & 0.0000408\\
     0.0001 & 2.500809 & 0.0000005  & 2.5007683 & 0.0000408\\  %\hline
    % \hline
   \end{tabular}
 \end{center}
 \caption[table]{Results and errors for three (3) tolerance values and two (2) ASI implementations, recursive and while-loop.}
 	\label{fig:21}
 \end{figure}

Using a recursive method is not recommended due to the large amount of calls. A notable difference between between ASI and recursiveASI, apart from the fact that the recursive is much easier to understand, is that ASI distributes its integration intervals equally, while the recursive puts a finer interval division on intervals that have high error (i.e. where the function changes rapidly). This allows the recursive method to give better result with equal amount of intervals. This more ``intelligent'' way of increasing the number of intervals could also be done in the while-loop implementation.




\end{document}
