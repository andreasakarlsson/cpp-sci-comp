\documentclass[paper=a4, fontsize=12pt]{article} % A4 paper and 11pt font size
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{a4wide}
\usepackage{float}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{makecell}
\usepackage{graphicx}
\usepackage[table]{xcolor}
\usepackage[numbered, framed]{mcode}  % To load matlab code
\lstset{deletestring=[b]{"}}

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead[L]{SF3565, Project 3, November 2016}
\fancyhead[R]{H{\"a}ggmark, Karlsson} % Empty left footer
\fancyfoot[C]{Program construction in C++ for Scientific Computing} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer

\title{Program construction in C++ for Scientific Computing \\ Teacher: Michael Hanke}

\author{Ilian H{\"a}ggmark \\ mail \href{mailto:ilianh@kth.se}{ilianh@kth.se}
  \and Andreas Karlsson \\ mail \href{mailto:andreas.a.karlsson@ki.se}{andreas.a.karlsson@ki.se} }
\date{\normalsize\today} % Today's date or a custom date

\begin{document}

\maketitle % Print the title

\section*{Project 3}
\subsection*{Task 1 - Abstract Class}

The function \texttt{fp()} in \texttt{Curvebase} is used to calculate $p$ with Newton's methods. This is performed many times and the efficiency should be considered. \texttt{fp()} needs the total length of the curve. This can be done by calling integrate. Doing this every time \texttt{fp()} is called is however not smart since the length of a curve is constant. We want to create a variable in the \texttt{Curvebase} that contains the length. \texttt{Curvebase} is however an abstract class an does no know anything about the curve. We solve this by declaring a length variable in \texttt{Curvebase} an the initializing the variable in the constructor of the inherited class. Setting length as a variable gives an increase in computational time by a factor $\sim 2.5$\\



\subsection*{Task 2 - Curve Generation}

The derived curve objects are quite simple since most of the machinery lies in the abstact class. The derived object main hold two important things: the limits of the curve and the destricption in terms of $x$ and $y$.

\subsection*{Task 3 - Domain Class}

The most important part in terms of efficiency for this project is the nested loop that calculated gridspoints inside the \texttt{generate\_grid()} function. The expresstion used to calculate the $x$ coordinate (for $y$-term $x$ is simply exchanged for $y$) from the nommalized arc length parameter s is

\begin{align*}
x[j+i*(m\_+1)]  &= \varphi_1(ih_1)\cdot \textrm{sides}[3]->x(jh_2) \\
	&+ \varphi_2(ih_1)\cdot \textrm{sides}[1]->x(jh_2) \\
	&+ \varphi_1(ih_2)\cdot \textrm{sides}[0]->x(ih_1) \\
	&+ \varphi_2(jh_2)\cdot \textrm{sides}[2]->x(ih_1) \\
	&- \varphi_1(ih_1) \varphi_1(jh_2) \cdot  \textrm{sides}[0]->x(0) \\
	&- \varphi_2(ih_1) \varphi_1(jh_2) \cdot  \textrm{sides}[1]->x(0) \\
	&- \varphi_1(ih_1) \varphi_2(jh_2) \cdot  \textrm{sides}[3]->x(1) \\
	&- \varphi_2(ih_1) \varphi_2(jh_2) \cdot  \textrm{sides}[2]->x(1)
\end{align*}

The four last term are corner correction terms. Calculating this expression $(m\_+1)(n\_+1)$ times it very inefficient since the calling calculating the $x$-function of a side is computationally heavy. We can however reduce the number of calls. The $\varphi$-function are very small and can be left as they are (inlining gives little improvement). We should however lift out the parts that contain the call to sides.$x()$. We note that the ``sides'' part of the four corner terms does not depend on $i$ and $j$. It is thus extremely inefficient to calculate them for every loop iterator. We can simply calculate them once before the loop starts. We also note that the first four lines are calculated $(m\_+1)(n\_+1)$ times even though $(m\_+1)$ times or $(n\_+1)$ times would be enough. We do this by calculating the first two lines in one loop and storing them in a vector, then doing the same thing for the 3rd and 4th line. The nested loop that finally puts everything together will thus not contain one call to the heavy $x$-function. This gives totally a decrease in computational time by a factor $\sim 400$.\\

\subsection*{Task 4 - Data Exportation}

The vectors \texttt{x\_} and \texttt{y\_} are concatenated before they are saved with
the code given in the task. The produced file can then be read and
visualized, as can be seen in Figure \ref{fig:grid}, using
the \textsc{Matlab} code below.

\begin{lstlisting}
  fid = fopen('outfile.bin','r'); % Open file
  c = fread(fid,'double');        % load file content to vector c

  x = c(1:length(c)/2);           % first half of c is x values
  y = c(length(c)/2+1:end);       % second half of c is y values

  plot(x,y,'.')                   % plot the x,y points
  \label{lst:matlab}.
\end{lstlisting}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{task4.pdf}
  \caption{Grid produced by the \texttt{generate\_grid()} method and plotted with \textsc{Matlab.}\label{fig:grid}}
\end{figure}

\subsection*{Task 5 - Grid streching}


\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{task5.pdf}
  \caption{A stretched grid produced by the \texttt{gammaStreachGrid()} method and plotted with \textsc{Matlab.}\label{fig:stretched}}
\end{figure}

A short function called stechGrid inside the Domain class is constructed. It loops through all $y$-values and change them slightly with the expression

$$ y_\textrm{strech}(y) = 3 \frac{\exp{1.5\frac{y}{3}}-1}{\exp{1.5}-1}$$

The value 1.5 tell how large the streaching is (changing the sign will determine the orientation). 3 is the maximum value of $y$. The stech value 1.5 is given as arguments to the function.

We also wrote an alternative function, \texttt{gammaStreachGrid()} which uses what is often refered to as ``gamma correction''

$$ y_\textrm{strech}(y) =  \left ( \frac{y-mi}{mx-mi}\right )^\gamma \cdot (mx-mi) + mi$$

The input to this function is the gamma values, $\gamma$, the minimum $y$-value $mi$ and the maximum $y$-value $mx$.

\end{document}
